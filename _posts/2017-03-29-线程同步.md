---
layout:     post
title:      线程同步
subtitle:   线程系列
date:       2017-03-29
author:     wan7451
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - Thread
    - Java
    - Android
    - Thread
    - ThreadPool
---
# 线程同步
在Android开发中，为了避免阻塞主线程，提高程序的运行效率，一般都会创建多个线程。但在多个线程同时运行时，有可能会调用到同一个方法或变量，由于CPU时间调度上的问题，写入数据会被多次的覆盖，出现不可预知的结果。为了避免这种问题，就要使线程同步。

如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。如果多个线程先后更改数据造成所得到的数据不是预期数据，则是线程不安全。

```
class TestRun implements Runnable {
    private int p;
    @Override
    public void run() {
        p++;
        System.out.println(p + "");
    }
}
```

```
TestRun run=new TestRun();
for (int i = 0; i < 5; i++) {
    Thread t=new Thread(run);
    t.start();
}
```

这段代码，我们期望的结果应该是 1 2 3 4 5 ，但是实际的结果却是 1 3 2 5 4。 这种情况便是线程不安全。

这是由什么原因造成的?要从Java多线程内存可见性说起。


Java Memory Model (JAVA 内存模型）描述线程之间如何通过内存(memory)来进行交互。 具体说来， JVM中存在一个主存区（Main Memory或Java Heap Memory），对于所有线程进行共享，而每个线程又有自己的工作内存（Working Memory），工作内存中保存的是主存中某些变量的拷贝，线程对所有变量的操作并非发生在主存区，而是发生在工作内存中，而线程之间是不能直接相互访问，变量在程序中的传递，是依赖主存来完成的。

Java内存模型的抽象示意图如下：








线程同步，就是用来解决线程不安全的问题。

![](https://github.com/Wan7451/wan7451.github.io/blob/master/_posts/images/thread-status.png?raw=true)

可以使用以下方式进行代码同步

1. 同步方法
2. 同步代码块
3. 使用特殊域变量(volatile)
4. 使用重入锁
5. 使用局部变量
6. 阻塞队列
7. 使用原子变量

> http://www.cnblogs.com/XHJT/p/3897440.html
> http://blog.csdn.net/beiyetengqing/article/details/49583381

