---
layout:     post
title:      线程同步(一)
subtitle:   线程系列
date:       2017-03-30
author:     wan7451
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - Thread
    - Java
    - Android
    - Thread
    - ThreadPool
---
# 线程同步(一)
在Android开发中，为了避免阻塞主线程，提高程序的运行效率，一般都会创建多个线程。但在多个线程同时运行时，有可能会调用到同一个方法或变量，由于CPU时间调度上的问题，写入数据会被多次的覆盖，出现不可预知的结果。为了避免这种问题，就要使线程同步。

如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。如果多个线程先后更改数据造成所得到的数据不是预期数据，则是线程不安全。

```
class TestRun implements Runnable {
    private int p;
    @Override
    public void run() {
        p++;
        System.out.println(p + "");
    }
}
```

```
TestRun run=new TestRun();
for (int i = 0; i < 5; i++) {
    Thread t=new Thread(run);
    t.start();
}
```

这段代码，我们期望的结果应该是 1 2 3 4 5 ，但是实际的结果却是 1 3 2 5 4。 这种情况便是线程不安全。

这是由什么原因造成的?要从Java内存模型说起。


### Java内存模型

JAVA 内存模型描述线程之间如何通过内存(memory)来进行交互。 具体说来， JVM中存在一个主存区（Main Memory或Java Heap Memory），对于所有线程进行共享，而每个线程又有自己的工作内存（Working Memory），工作内存中保存的是主存中某些变量的拷贝，线程对所有变量的操作并非发生在主存区，而是发生在工作内存中，而线程之间是不能直接相互访问，变量在程序中的传递，是依赖主存来完成的。

Java内存模型的抽象示意图如下：
![](https://github.com/Wan7451/wan7451.github.io/blob/master/_posts/images/thread-memory.png?raw=true)

从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：

1. 线程A把本地内存A中更新过的共享变量刷新到主内存中去。
2. 线程B到主内存中去读取线程A之前已更新过的共享变量。

下面通过示意图来说明这两个步骤：
![](https://github.com/Wan7451/wan7451.github.io/blob/master/_posts/images/thread-memory2.png?raw=true)

本地内存A和B有主内存中共享变量x的副本。

1. 假设初始时，这三个内存中的x值都为0。
2. 线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。
3. 当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。
4. 随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。

### 内存可见性

如果线程A对共享变量X进行了修改，但是线程A没有及时把更新后的值刷入到主内存中，而此时线程B从主内存读取共享变量X的值，所以X的值是原始值，那么我们就说对于线程B来讲，共享变量X的更改对线程B是不可见的。




下面这张图描述了结果不可预知的原因。

![](https://github.com/Wan7451/wan7451.github.io/blob/master/_posts/images/thread-memory3.png?raw=true)

1. 有共享变量值为1000000；
2. 线程1拿到共享变量副本后，进行了 +1 的操作；
3. 但还未把最新值写入主内存，CPU就停止了线程1的执行；
4. 并且执行线程2，线程2首先从主内存中获取共享变量值；
5. 然后 -1；
6. 把值更新到主内存中；
7. CPU终止了线程2的执行，转而继续执行线程1；
8. 线程1把最新值刷入主内存，所以主内存结果变为了1000001.

通过上面的分析，我们得知：内存不可见是由于共享变量的值没有及时在主内存中更新，为什么没有及时更新呢？是因为加一（或者减一）的操作不具备原子性（上面例子最后一步被打断）。所谓原子性是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会被打断。

那么如何保证操作具有原子性呢？这里我们使用线程同步，解决线程不安全的问题。


---

Java 并发编程

* 共享性   数据共享性是线程安全的主要原因之一。如果所有的数据只是在线程内有效，那就不存在线程安全性问题，这也是我们在编程的时候经常不需要考虑线程安全的主要原因之一。但是，在多线程编程中，数据共享是不可避免的。最典型的场景是数据库中的数据，为了保证数据的一致性，我们通常需要共享同一个数据库中数据。
* 互斥性   资源互斥是指同时只允许一个访问者对其进行访问，具有唯一性和排它性。我们通常允许多个线程同时对数据进行读操作，但同一时间内只允许一个线程对数据进行写操作。所以我们通常将锁分为共享锁和排它锁，也叫做读锁和写锁。如果资源不具有互斥性，即使是共享资源，我们也不需要担心线程安全。例如，对于不可变的数据共享，所有线程都只能对其进行读操作，所以不用考虑线程安全问题。但是对共享数据的写操作，一般就需要保证互斥性。
* 原子性   原子性就是指对数据的操作是一个独立的、不可分割的整体。换句话说，就是一次操作，是一个连续不可中断的过程，数据不会执行的一半的时候被其他线程所修改。
* 可见性   
* 有序性





> http://www.cnblogs.com/XHJT/p/3897440.html
> http://blog.csdn.net/beiyetengqing/article/details/49583381
> http://www.cnblogs.com/paddix/p/5374810.html

